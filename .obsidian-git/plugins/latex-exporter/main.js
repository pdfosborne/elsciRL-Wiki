/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ExportPaperPlugin
});
module.exports = __toCommonJS(main_exports);
var path2 = __toESM(require("path"));
var import_obsidian4 = require("obsidian");

// src/export_longform/utils.ts
var import_obsidian = require("obsidian");
function notice_and_warn(message) {
  new import_obsidian.Notice(message);
  console.warn(message);
}
function escape_latex(input) {
  return input.replace(/\\/g, "\\textbackslash{}").replace(/%/g, "\\%").replace(/&/g, "\\&").replace(/#/g, "\\#").replace(/\$/g, "\\$").replace(/_/g, "\\_").replace(/\{/g, "\\{").replace(/\}/g, "\\}").replace(/\^/g, "\\^{}").replace(/~/g, "\\textasciitilde{}").replace(/</g, "\\textless{}").replace(/>/g, "\\textgreater{}").replace(/\|/g, "\\textbar{}").replace(/"/g, "''").replace(/'/g, "`");
}
function find_image_file(find_file, address) {
  const matchExcalidraw = /^.*\.excalidraw$/.exec(address);
  if (matchExcalidraw !== null) {
    address = matchExcalidraw[0] + ".png";
  }
  return find_file(address);
}
function strip_newlines(thestring) {
  const result = /^(?:(?:\s*?)\n)*(.*?)(?:\n(?:\s*?))?$/s.exec(thestring);
  if (result === null) {
    throw new Error("result is undefined");
  }
  return result[1];
}

// src/export_longform/interfaces.ts
var DEFAULT_SETTINGS = {
  mySetting: "default",
  template_path: "",
  base_output_folder: "/",
  preamble_file: "preamble.sty",
  bib_file: "bibliography.bib",
  prioritize_lists: false,
  // Whether to parse lists or equations first. Lists first allows lists containing display equations, but yields bugs because lines within an equation can easily start with '-'.
  warn_before_overwrite: true,
  default_citation_command: "cite"
};
function init_data(longform_file, read_tfile, find_file) {
  return {
    in_thm_env: false,
    depth: 0,
    env_hash_list: [],
    parsed_file_bundle: {},
    ambient_header_level: 0,
    headers_level_offset: 0,
    explicit_env_index: 1,
    longform_file,
    current_file: longform_file,
    read_tfile,
    find_file,
    header_stack: [],
    // file-local stack of headers.
    media_files: [],
    bib_keys: []
  };
}
function address_is_image_file(address) {
  if (/\.(?:jpeg|svg|pdf|png|jpg|gif|svg|pdf|tiff|excalidraw?)$/.exec(address)) {
    return true;
  }
  return false;
}
async function unroll_array(data, content_array, settings) {
  const new_children = [];
  for (const elt of content_array) {
    new_children.push(...await elt.unroll(data, settings));
  }
  return new_children;
}

// src/export_longform/headers.ts
var ProofHeader = class {
  constructor(title) {
    this.title = title;
  }
  async unroll() {
    return [this];
  }
  async latex(buffer, buffer_offset, settings) {
    const header_string = "\n\\textbf{" + this.title + "}\n\n";
    buffer_offset += buffer.write(header_string, buffer_offset);
    return buffer_offset;
  }
};
var Header = class {
  constructor(level, title, children, label, data) {
    this.level = level;
    this.title = title;
    this.children = children;
    this.label = label;
    if (data !== void 0) {
      this.data = data;
    }
  }
  async unroll(data, settings) {
    if (data.in_thm_env) {
      const new_children2 = [];
      for (const elt of this.children) {
        new_children2.push(...await elt.unroll(data, settings));
      }
      return [
        new ProofHeader(await this.latex_title(settings)),
        ...new_children2
      ];
    }
    this.level += data.headers_level_offset;
    data.ambient_header_level = this.level;
    for (let i = 0; i < data.header_stack.length; i++) {
      if (data.header_stack[i].level >= this.level) {
        data.header_stack = data.header_stack.slice(0, i);
        break;
      }
    }
    data.header_stack.push(this);
    this.data = {
      in_thm_env: data.in_thm_env,
      depth: data.depth,
      env_hash_list: data.env_hash_list,
      parsed_file_bundle: data.parsed_file_bundle,
      ambient_header_level: data.ambient_header_level,
      headers_level_offset: data.headers_level_offset,
      explicit_env_index: data.explicit_env_index,
      read_tfile: data.read_tfile,
      find_file: data.find_file,
      longform_file: data.longform_file,
      current_file: data.current_file,
      header_stack: [...data.header_stack],
      media_files: data.media_files,
      bib_keys: data.bib_keys
    };
    const new_title = [];
    for (const elt of this.title) {
      new_title.push(...await elt.unroll(data, settings));
    }
    this.title = new_title;
    const new_children = [];
    for (const elt of this.children) {
      new_children.push(...await elt.unroll(data, settings));
    }
    this.children = new_children;
    return [this];
  }
  async latex_title(settings) {
    const buffer = Buffer.alloc(1e3);
    let buffer_offset = 0;
    for (const e of this.title) {
      buffer_offset = await e.latex(buffer, buffer_offset, settings);
    }
    return buffer.toString("utf8", 0, buffer_offset);
  }
  async latex(buffer, buffer_offset, settings) {
    const header_title = await this.latex_title(settings);
    let header_string = "";
    if (this.level === 1) {
      header_string = "\\section{" + header_title + "}\n";
    } else if (this.level === 2) {
      header_string = "\\subsection{" + header_title + "}\n";
    } else if (this.level === 3) {
      header_string = "\\subsubsection{" + header_title + "}\n";
    } else if (this.level >= 4) {
      header_string = "\n\\textbf{" + header_title + "}\n\n";
    }
    buffer_offset += buffer.write(header_string, buffer_offset);
    const promises = this.data.header_stack.map(
      async (e) => await e.latex_title(settings)
    );
    buffer_offset += buffer.write(
      "\\label{" + await label_from_location(
        this.data,
        this.data.current_file.basename,
        //File the header came from
        settings,
        await Promise.all(promises)
      ) + "}\n",
      buffer_offset
    );
    for (const e of this.children) {
      buffer_offset = await e.latex(buffer, buffer_offset, settings);
    }
    return buffer_offset;
  }
};
async function find_header(header, current_content, settings) {
  let header_stack;
  if (typeof header === "string") {
    header_stack = header.split("#").reverse();
  } else {
    header_stack = [...header];
  }
  const next_checks = [];
  for (const node5 of current_content) {
    for (const elt of node5) {
      if (elt instanceof Header) {
        const current_check = header_stack[header_stack.length - 1];
        if (current_check === void 0) {
          throw new Error(
            "current_check is undefined, should not be possible."
          );
        }
        if (header_stack.length > 0 && (await elt.latex_title(settings)).toLowerCase().trim() == current_check.toLowerCase().trim()) {
          if (header_stack.length == 1) {
            return elt;
          }
          header_stack.pop();
        }
        next_checks.push(elt.children);
      }
    }
  }
  if (next_checks.length == 0) {
    return void 0;
  }
  return await find_header(header_stack, next_checks, settings);
}
async function get_header_address(header, current_content, settings, built_address) {
  let header_stack;
  if (typeof header === "string") {
    header_stack = header.split("#").reverse();
  } else {
    header_stack = [...header];
  }
  for (const elt of current_content) {
    if (elt instanceof Header) {
      const current_check = header_stack[header_stack.length - 1];
      console.assert(
        current_check !== void 0,
        "current_check is undefined"
      );
      const new_address = built_address === void 0 ? await elt.latex_title(settings) : built_address + "." + await elt.latex_title(settings);
      if (header_stack.length > 0 && (await elt.latex_title(settings)).toLowerCase().trim() == current_check.toLowerCase().trim()) {
        if (header_stack.length == 1) {
          return new_address;
        }
        header_stack.pop();
      }
      const attempt = await get_header_address(
        header_stack,
        elt.children,
        settings,
        new_address
      );
      if (attempt !== void 0) {
        return attempt;
      }
    }
  }
  return void 0;
}

// src/export_longform/labels.ts
function format_label(label) {
  return label.toLowerCase().trim().replace(/\\autoref{/g, "").replace(/}/g, "").replace(/ /g, "_").replace(/,/g, "").replace(/-/g, ":");
}
function explicit_label(longform_file, current_file, label) {
  if (current_file !== longform_file) {
    return explicit_label_with_address(label, current_file.basename);
  } else {
    return label;
  }
}
function explicit_label_with_address(label, address) {
  const match = /^([a-z]+)-(.*)$/.exec(label);
  if (match) {
    return format_label(match[1] + ":" + address + "." + match[2]);
  } else {
    return format_label(address + "." + label);
  }
}
async function label_from_location(data, address, settings, header) {
  if (address_is_image_file(address)) {
    return format_label("fig:" + address);
  }
  if (header === "" || header === void 0) {
    header = "statement";
  }
  let resolved_head_label = await resolve_header_label(
    address,
    header,
    data.parsed_file_bundle,
    data.find_file,
    settings
  );
  if (resolved_head_label === void 0) {
    notice_and_warn(
      "could not resolve header at " + address + ": " + header + " keeping the header label as-is"
    );
    resolved_head_label = typeof header === "string" ? header : header.join(".");
  }
  if (address === "" || address === data.longform_file.basename) {
    return format_label("loc:" + resolved_head_label);
  }
  return format_label("loc:" + address + "." + resolved_head_label);
}
async function resolve_header_label(address, header, file_cache, find_file, settings) {
  let file_content;
  const cached_content = file_cache[address];
  if (cached_content === void 0) {
    const file = find_file(address);
    if (file === void 0 || file_cache[file.basename] === void 0) {
      if (file !== void 0 && file_cache[file.basename] === void 0) {
        notice_and_warn(
          "address of reference '" + address + "' is referenced but was not embedded."
        );
      }
      const header_string = typeof header === "string" ? header : header.join(".");
      notice_and_warn(
        "keeping the header address of " + address + ": " + header_string + " as-is"
      );
      return header_string;
    }
    file_content = file_cache[file.basename].body;
  } else {
    file_content = cached_content.body;
  }
  let new_label;
  if (typeof header === "string") {
    new_label = await get_header_address(header, file_content, settings);
  } else {
    new_label = await get_header_address(
      [...header].reverse(),
      file_content,
      settings
    );
  }
  if (new_label === void 0) {
    const header_string = typeof header === "string" ? header : header.join(".");
    notice_and_warn(
      "Could not resolve header name '" + header_string + "' in file with address '" + address + "', keeping the header label as-is"
    );
    return header_string;
  }
  return new_label;
}

// src/export_longform/inline.ts
function split_inline(inline_arr, class_regexp, make_obj, settings) {
  const new_inline = [];
  for (const text of inline_arr) {
    if (text instanceof Text) {
      let current_match = null;
      let start_index = 0;
      while ((current_match = class_regexp.exec(text.content)) !== null) {
        if (current_match.index == null) {
          throw new Error("current_match.index is undefined");
        }
        const prev_chunk = text.content.slice(
          start_index,
          current_match.index
        );
        if (prev_chunk !== "") {
          new_inline.push(new Text(prev_chunk));
        }
        new_inline.push(make_obj(current_match, settings));
        start_index = current_match.index + current_match[0].length;
      }
      const last_string = text.content.slice(start_index);
      if (last_string !== "") {
        new_inline.push(new Text(last_string));
      }
    } else {
      new_inline.push(text);
    }
  }
  return new_inline;
}
var ExplicitRef = class {
  constructor(identifier, name) {
    this.label = identifier + "-" + name;
  }
  static get_regexp() {
    return /@(ref|loc|tbl|eq|lem|sec|lst|thm|def|ex|exr|prf|alg)\-([\w_:\-]+)/g;
  }
  static build_from_match(regexmatch, settings) {
    return new ExplicitRef(regexmatch[1], regexmatch[2]);
  }
  async unroll(data, settings) {
    return [this];
  }
  async latex(buffer, buffer_offset, settings) {
    return buffer_offset + buffer.write(
      "\\autoref{" + format_label(this.label) + "}",
      buffer_offset
    );
  }
};
var Text = class {
  constructor(content) {
    this.content = content;
  }
  async unroll() {
    return [this];
  }
  async latex(buffer, buffer_offset, settings) {
    return buffer_offset + buffer.write(this.content, buffer_offset);
  }
};
var Emphasis = class {
  static get_regexp() {
    return /(?:\*(\S.*?)\*)|(?:_(\S.*?)_)/gs;
  }
  static build_from_match(regexmatch, settings) {
    if (regexmatch[1] !== void 0) {
      return new Emphasis(regexmatch[1]);
    } else if (regexmatch[2] !== void 0) {
      return new Emphasis(regexmatch[2]);
    } else {
      throw new Error("Unexpected regex match");
    }
  }
  constructor(content) {
    this.content = content;
  }
  async unroll() {
    return [this];
  }
  async latex(buffer, buffer_offset, settings) {
    return buffer_offset + buffer.write("\\emph{" + this.content + "}", buffer_offset);
  }
};
var DoubleQuotes = class {
  static get_regexp() {
    return /(?:"(\S.*?)")/gs;
  }
  static build_from_match(regexmatch, settings) {
    return new DoubleQuotes(regexmatch[1]);
  }
  constructor(content) {
    this.content = content;
  }
  async unroll() {
    return [this];
  }
  async latex(buffer, buffer_offset, settings) {
    return buffer_offset + buffer.write("``" + this.content + '"', buffer_offset);
  }
};
var SingleQuotes = class {
  static get_regexp() {
    return /(?:'(\S.*?)')/gs;
  }
  static build_from_match(regexmatch, settings) {
    return new SingleQuotes(regexmatch[1]);
  }
  constructor(content) {
    this.content = content;
  }
  async unroll() {
    return [this];
  }
  async latex(buffer, buffer_offset, settings) {
    return buffer_offset + buffer.write("`" + this.content + "'", buffer_offset);
  }
};
var Strong = class {
  // similar to emphasis but with double asterisks
  static get_regexp() {
    return /(?:\*\*(\S.*?)\*\*)|(?:__(\S.*?)__)/gs;
  }
  static build_from_match(regexmatch, settings) {
    if (regexmatch[1] !== void 0) {
      return new Strong(regexmatch[1]);
    } else if (regexmatch[2] !== void 0) {
      return new Strong(regexmatch[2]);
    } else {
      throw new Error("Unexpected regex match");
    }
  }
  constructor(content) {
    this.content = content;
  }
  async unroll() {
    return [this];
  }
  async latex(buffer, buffer_offset, settings) {
    return buffer_offset + buffer.write("\\textbf{" + this.content + "}", buffer_offset);
  }
};
var InlineMath = class {
  static get_regexp() {
    return /\$([^\$]+)\$(?:{(.*?)})?/g;
  }
  static build_from_match(regexmatch, settings) {
    return new InlineMath(regexmatch[1], regexmatch[2]);
  }
  constructor(content, label) {
    this.content = content;
    this.label = label;
  }
  async unroll() {
    return [this];
  }
  async latex(buffer, buffer_offset, settings) {
    return buffer_offset + buffer.write("$" + this.content + "$", buffer_offset);
  }
};

// src/export_longform/display.ts
function split_display(display_elts, make_obj, class_regexp, settings) {
  const new_display = [];
  for (const elt of display_elts) {
    if (elt instanceof Paragraph) {
      console.assert(
        elt.elements.length == 1,
        "Paragraph should have only one element at this stage of parsing"
      );
      console.assert(
        elt.elements[0] instanceof Text,
        "Paragraph should have only one text element at this stage of parsing"
      );
      const inline_element = elt.elements[0];
      let current_match = null;
      let start_index = 0;
      const string_to_parse = inline_element.content;
      while ((current_match = class_regexp.exec(string_to_parse)) !== null) {
        if (current_match.index == void 0) {
          throw new Error("current_match.index is undefined");
        }
        const prev_chunk = inline_element.content.slice(
          start_index,
          current_match.index
        );
        if (prev_chunk.trim() !== "") {
          new_display.push(
            new Paragraph([new Text(strip_newlines(prev_chunk))])
          );
        }
        new_display.push(make_obj(current_match, settings));
        start_index = current_match.index + current_match[0].length;
      }
      const return_string = strip_newlines(
        inline_element.content.slice(start_index)
      );
      if (return_string.trim() !== "") {
        new_display.push(new Paragraph([new Text(return_string)]));
      }
    } else {
      new_display.push(elt);
    }
  }
  return new_display;
}
var DisplayMath = class {
  static get_regexp() {
    return /\$\$\s*(?:\\begin{(\S*?)}\s*([\S\s]*?)\s*\\end{\1}|([\S\s]*?))\s*?\$\$(?:\s*?{#(\S*?)})?/gs;
  }
  static build_from_match(match, settings) {
    const latex = match[2] === void 0 ? match[3] : match[2];
    const label_match = /eq-(\w+)/.exec(match[1]);
    let label_val = match[1];
    if (label_match && label_match[1] !== void 0) {
      label_val = label_match[1];
    }
    return new DisplayMath(latex, match[4], label_val);
  }
  constructor(latex, label, explicit_env) {
    this.content = latex;
    this.label = label;
    this.explicit_env_name = explicit_env;
  }
  async unroll() {
    return [this];
  }
  async latex(buffer, buffer_offset, settings) {
    let env_name = "equation*";
    if (this.label !== void 0) {
      env_name = "equation";
      if (this.explicit_env_name !== void 0 && ["equation*", "align*"].includes(this.explicit_env_name)) {
        notice_and_warn(
          `Environment ${this.explicit_env_name} does not support labels. Ignoring label ${this.label}`
        );
      }
      if (this.explicit_env_name !== void 0 && ["align"].includes(this.explicit_env_name)) {
        const label = format_label(this.label);
        const lines = this.content.split("\\\\");
        const numlines = lines.length;
        const labeled_lines = [];
        lines.forEach((line, index) => {
          if (line.trim() !== "") {
            let new_text = line + ` \\label{${label}:${index + 1}}`;
            if (index < numlines - 1) {
              new_text += "\\\\";
            }
            labeled_lines.push(new_text);
          }
        });
        this.content = labeled_lines.join("");
      } else {
        this.content = "\\label{" + format_label(this.label) + "}\n" + this.content;
      }
    }
    if (this.explicit_env_name !== void 0) {
      if ([
        "equation",
        "equation*",
        "align",
        "align*",
        "multline",
        "multline*",
        "gather",
        "gather*"
      ].includes(this.explicit_env_name)) {
        env_name = this.explicit_env_name;
      } else {
        this.content = "\\begin{" + this.explicit_env_name + "}\n" + this.content + "\n\\end{" + this.explicit_env_name + "}";
      }
    }
    buffer_offset += buffer.write(
      "\\begin{" + env_name + "}\n",
      buffer_offset
    );
    buffer_offset += buffer.write(this.content + "\n", buffer_offset);
    buffer_offset += buffer.write(
      "\\end{" + env_name + "}\n",
      buffer_offset
    );
    return buffer_offset;
  }
};
var Paragraph = class {
  constructor(elements) {
    this.elements = elements;
  }
  async unroll(data, settings) {
    const new_elements = [];
    for (const elt of this.elements) {
      new_elements.push(...await elt.unroll(data, settings));
    }
    this.elements = new_elements;
    return [this];
  }
  async latex(buffer, buffer_offset, settings) {
    let new_offset = buffer_offset;
    for (const elt of this.elements) {
      new_offset = await elt.latex(buffer, new_offset, settings);
    }
    new_offset += buffer.write("\n", new_offset);
    return new_offset;
  }
};
var BlankLine = class {
  static get_regexp() {
    return /\n\s*\n/g;
  }
  static build_from_match() {
    return new BlankLine();
  }
  async unroll() {
    return [this];
  }
  async latex(buffer, buffer_offset, settings) {
    return buffer_offset + buffer.write("\n", buffer_offset);
  }
};
var Quote = class {
  static get_regexp() {
    return /^>(.*)$/gm;
  }
  constructor(content) {
    this.content = content;
  }
  static build_from_match(regexmatch, settings) {
    return new Quote(regexmatch[1]);
  }
  async unroll() {
    return [this];
  }
  async latex(buffer, buffer_offset, settings) {
    return buffer_offset + buffer.write("%" + this.content + "\n", buffer_offset);
  }
};
var NumberedList = class {
  static get_regexp() {
    return /(?<=^|\n)[ \t]*?1\. (.*?)(?:2\. (.*?))?(?:3\. (.*?))?(?:4\. (.*?))?(?:5\. (.*?))?(?:6\. (.*?))?(?:7\. (.*?))?(?:8\. (.*?))?(?:9\. (.*?))?(?:10\. (.*?))?(?:11\. (.*?))?(?:12\. (.*?))?(?:13\. (.*?))?(?:14\. (.*?))?(?:15\. (.*?))?(?:16\. (.*?))?(?:17\. (.*?))?(?:18\. (.*?))?(?:19\. (.*?))?(?:20\. (.*?))?$/gs;
  }
  constructor(content) {
    this.content = content;
  }
  static build_from_match(regexmatch, settings) {
    const list_contents = [];
    for (const e of regexmatch.slice(1)) {
      if (e === void 0) {
        break;
      }
      list_contents.push(e);
    }
    return new NumberedList(
      list_contents.map((e) => [new Paragraph([new Text(e)])])
    );
  }
  async unroll(data, settings) {
    const new_content = [];
    for (const e of this.content) {
      new_content.push(await unroll_array(data, e, settings));
    }
    return [new NumberedList(new_content)];
  }
  async latex(buffer, buffer_offset, settings) {
    buffer_offset += buffer.write("\\begin{enumerate}\n", buffer_offset);
    for (const e of this.content) {
      buffer_offset += buffer.write("\\item ", buffer_offset);
      for (const f of e) {
        buffer_offset = await f.latex(buffer, buffer_offset, settings);
      }
    }
    buffer_offset += buffer.write("\\end{enumerate}\n", buffer_offset);
    return buffer_offset;
  }
};
var UnorderedList = class {
  static get_regexp() {
    return /(?<=^|\n)[ \t]*?(?:-|\+|\*) (.*?)(?:\n\s*?(?:-|\+|\*) (.*?))?(?:\n\s*?(?:-|\+|\*) (.*?))?(?:\n\s*?(?:-|\+|\*) (.*?))?(?:\n\s*?(?:-|\+|\*) (.*?))?(?:\n\s*?(?:-|\+|\*) (.*?))?(?:\n\s*?(?:-|\+|\*) (.*?))?(?:\n\s*?(?:-|\+|\*) (.*?))?(?:\n\s*?(?:-|\+|\*) (.*?))?(?:\n\s*?(?:-|\+|\*) (.*?))?(?:\n\s*?(?:-|\+|\*) (.*?))?(?:\n\s*?(?:-|\+|\*) (.*?))?(?:\n\s*?(?:-|\+|\*) (.*?))?(?:\n\s*?(?:-|\+|\*) (.*?))?(?:\n\s*?(?:-|\+|\*) (.*?))?(?:\n\s*?(?:-|\+|\*) (.*?))?$/gs;
  }
  constructor(content) {
    this.content = content;
  }
  static build_from_match(regexmatch, settings) {
    const list_contents = [];
    for (const e of regexmatch.slice(1)) {
      if (e === void 0) {
        break;
      }
      list_contents.push(e);
    }
    return new UnorderedList(
      list_contents.map((e) => [new Paragraph([new Text(e)])])
    );
  }
  async unroll(data, settings) {
    const new_content = [];
    for (const e of this.content) {
      new_content.push(await unroll_array(data, e, settings));
    }
    return [new UnorderedList(new_content)];
  }
  async latex(buffer, buffer_offset, settings) {
    buffer_offset += buffer.write("\\begin{itemize}\n", buffer_offset);
    for (const e of this.content) {
      buffer_offset += buffer.write("\\item ", buffer_offset);
      for (const f of e) {
        buffer_offset = await f.latex(buffer, buffer_offset, settings);
      }
    }
    buffer_offset += buffer.write("\\end{itemize}\n", buffer_offset);
    return buffer_offset;
  }
};
var Comment = class {
  static get_regexp() {
    return /\%\%(.*?)\%\%/gs;
  }
  constructor(content) {
    this.content = content;
  }
  static build_from_match(regexmatch, settings) {
    return new Comment(regexmatch[1]);
  }
  async unroll() {
    return [this];
  }
  async latex(buffer, buffer_offset, settings) {
    return buffer_offset;
  }
};

// src/export_longform/wikilinks.ts
var path = __toESM(require("path"));
var import_obsidian2 = require("obsidian");
var import_console = require("console");
var EmbedWikilink = class {
  static get_regexp() {
    return /(?:(\S*?)::)?!\[\[([\s\S]*?)(?:#([\s\S]+?))?(?:\|([\s\S]*?))?\]\]/g;
  }
  static build_from_match(args, settings) {
    return new EmbedWikilink(args[1], args[2], args[3], args[4]);
  }
  constructor(attribute, address, header, displayed) {
    this.attribute = attribute;
    this.content = address;
    this.header = header;
    this.display = displayed;
  }
  async unroll(data, settings) {
    if (address_is_image_file(this.content)) {
      const file = find_image_file(data.find_file, this.content);
      if (file === void 0) {
        const err_msg = "Content not found: Could not find the content of the plot with image '" + escape_latex(this.content) + "'";
        notice_and_warn(err_msg);
        return [
          new BlankLine(),
          new Paragraph([new Text(err_msg)]),
          new BlankLine()
        ];
      } else {
        data.media_files.push(file);
        const p = new Plot(file, this.display);
        p.label = await label_from_location(data, file.name, settings);
        return [p];
      }
    }
    if (this.display !== void 0) {
      return [new Text(this.display)];
    }
    const return_data = await parse_embed_content(
      this.content,
      data.find_file,
      data.read_tfile,
      data.parsed_file_bundle,
      settings,
      this.header
    );
    if (return_data === void 0) {
      const err_msg = "Content not found: Could not find the content of \\emph{" + escape_latex(this.content) + "} with header \\emph{" + this.header + "}";
      const other_err_msg = "Content not found: Could not find the content of '" + escape_latex(this.content) + "' with header '" + this.header + "'";
      new import_obsidian2.Notice(other_err_msg);
      return [
        new BlankLine(),
        new Paragraph([new Text(err_msg)]),
        new BlankLine()
      ];
    }
    const [parsed_contents, level_of_header_being_embedded] = return_data;
    const ambient_header_level_outside = data.ambient_header_level;
    const ambient_header_offset_outside = data.headers_level_offset;
    const ambient_header_stack = data.header_stack;
    data.header_stack = [];
    data.headers_level_offset = data.ambient_header_level - level_of_header_being_embedded;
    const unrolled_contents = [];
    const was_in_thm_env = data.in_thm_env;
    if (this.attribute !== void 0) {
      data.in_thm_env = true;
    }
    const candidate_file = data.find_file(this.content);
    if (candidate_file === void 0) {
      throw new Error("Could not find file: " + this.content);
    }
    const ambient_current_file = data.current_file;
    data.current_file = candidate_file;
    for (const elt of parsed_contents) {
      unrolled_contents.push(...await elt.unroll(data, settings));
    }
    if (!was_in_thm_env) {
      data.in_thm_env = false;
    }
    data.ambient_header_level = ambient_header_level_outside;
    data.headers_level_offset = ambient_header_offset_outside;
    data.current_file = ambient_current_file;
    data.header_stack = ambient_header_stack;
    const address = this.content === "" ? data.longform_file.basename : this.content;
    if (this.attribute !== void 0) {
      return [
        new Environment(
          unrolled_contents,
          this.attribute,
          await label_from_location(
            data,
            address,
            settings,
            this.header
          )
        )
      ];
    }
    return unrolled_contents;
  }
  async latex(buffer, buffer_offset, settings) {
    console.error(
      "Embed wikilink " + this.content + "should have been unrolled to something else"
    );
    return 0;
  }
};
var Plot = class {
  constructor(image, caption) {
    this.image = image;
    this.caption = caption;
  }
  async unroll() {
    return [this];
  }
  async latex(buffer, buffer_offset, settings) {
    buffer_offset += buffer.write(
      `\\begin{figure}[h]
\\centering
\\includegraphics[width=0.5\\textwidth]{` + path.join("Files", this.image.name) + "}\n",
      buffer_offset
    );
    let caption_text;
    if (this.caption === void 0) {
      caption_text = "";
      const warning = "WARNING: Figure created from '" + this.image.name + "' has no caption.";
      notice_and_warn(warning);
    } else {
      caption_text = this.caption;
    }
    buffer_offset += buffer.write(
      "\\caption{" + caption_text + "\\label{" + this.label + "}}\n",
      buffer_offset
    );
    buffer_offset += buffer.write("\\end{figure}\n", buffer_offset);
    return buffer_offset;
  }
};
var Wikilink = class {
  static get_regexp() {
    return /(?:(\S*?)::)?\[\[([\s\S]*?)(?:\#([\s\S]*?))?(?:\|([\s\S]*?))?\]\]/g;
  }
  static build_from_match(args, settings) {
    return new Wikilink(args[1], args[2], args[3], args[4]);
  }
  constructor(attribute, address, header, displayed) {
    this.attribute = attribute;
    this.content = address;
    this.header = header;
    this.displayed = displayed;
  }
  async unroll(data, settings) {
    if (this.content === "") {
      this.content = data.current_file.basename;
    }
    return [
      new UnrolledWikilink(
        data,
        this.attribute,
        this.content,
        this.header,
        this.displayed
      )
    ];
  }
  async latex(buffer, buffer_offset, settings) {
    if (this.header === void 0) {
      this.header = "";
    }
    return buffer_offset + buffer.write(
      "[[" + this.content + "#" + this.header + "]]",
      buffer_offset
    );
  }
};
var Environment = class {
  // Can parse a label as well
  static get_regexp() {
    return /^(\w+?)::(?:\s*?{#([\S ]*?)})?(.*?)::\1/gms;
  }
  // address_of_origin: string | undefined;
  constructor(children, type, label) {
    this.children = children;
    this.type = type.toLowerCase().trim();
    this.label = label;
  }
  static build_from_match(match, settings) {
    let [_, body] = parse_display(strip_newlines(match[3]), settings);
    body = parse_after_headers(body, settings);
    traverse_tree_and_parse_inline(body, settings);
    return new Environment(
      // Here we must run a full parsing on the contents instead of inserting a string.
      // parse_note(strip_newlines(match[3])).body,
      body,
      match[1],
      match[2]
    );
  }
  async unroll(data, settings) {
    if (this.label !== void 0) {
      this.label = explicit_label(
        data.longform_file,
        data.current_file,
        this.label
      );
    }
    this.children = await unroll_array(data, this.children, settings);
    return [this];
  }
  async latex(buffer, buffer_offset, settings) {
    buffer_offset += buffer.write(
      "\\begin{" + this.type + "}",
      buffer_offset
    );
    if (this.label !== void 0) {
      if (this.type === "proof") {
        buffer_offset += buffer.write(
          "[\\hypertarget{" + this.label + "}Proof of \\autoref{" + this.label.replace("proof", "statement") + "}]\n",
          buffer_offset
        );
      } else {
        buffer_offset += buffer.write(
          "\n\\label{" + format_label(this.label) + "}\n",
          buffer_offset
        );
      }
    } else {
      buffer_offset += buffer.write("\n", buffer_offset);
    }
    for (const e of this.children) {
      buffer_offset = await e.latex(buffer, buffer_offset, settings);
    }
    buffer_offset += buffer.write(
      "\\end{" + this.type + "}\n",
      buffer_offset
    );
    return buffer_offset;
  }
};
var UnrolledWikilink = class {
  constructor(unroll_data, attribute, address, header, displayed) {
    (0, import_console.assert)(!/^@/.exec(address), "Should not be a citation");
    this.unroll_data = {
      in_thm_env: unroll_data.in_thm_env,
      depth: unroll_data.depth,
      env_hash_list: unroll_data.env_hash_list,
      parsed_file_bundle: unroll_data.parsed_file_bundle,
      ambient_header_level: unroll_data.ambient_header_level,
      headers_level_offset: unroll_data.headers_level_offset,
      explicit_env_index: unroll_data.explicit_env_index,
      find_file: unroll_data.find_file,
      read_tfile: unroll_data.read_tfile,
      longform_file: unroll_data.longform_file,
      current_file: unroll_data.current_file,
      header_stack: [...unroll_data.header_stack],
      media_files: [...unroll_data.media_files],
      bib_keys: [...unroll_data.bib_keys]
    };
    this.address = address;
    this.attribute = attribute;
    this.address = address;
    this.header = header;
    this.displayed = displayed;
  }
  async latex(buffer, buffer_offset, settings) {
    var _a;
    const label = await label_from_location(
      this.unroll_data,
      this.address,
      settings,
      this.header
    );
    if (this.displayed !== void 0) {
      return buffer_offset + buffer.write(
        "\\hyperref[" + label + "]{" + this.displayed + "}",
        buffer_offset
      );
    }
    if (((_a = this.header) == null ? void 0 : _a.toLowerCase().trim()) !== "proof") {
      return buffer_offset + buffer.write("\\autoref{" + label + "}", buffer_offset);
    } else {
      return buffer_offset + buffer.write(
        "\\hyperlink{" + label + "}{the proof}",
        buffer_offset
      );
    }
  }
  async unroll() {
    return [this];
  }
};
var Citation = class {
  static get_regexp() {
    return /(?:\[([^@\[]*?)\])?(?:(?:\[\[@([a-zA-Z0-9\.\-_]*)\]\])|(?:(\[\-)?@([a-zA-Z0-9\-_]*)\]?))(?:\[([^@\[]*?)\])?/g;
  }
  static build_from_match(args, settings) {
    let captured_id = void 0;
    if (args[2] !== void 0) {
      captured_id = args[2];
    } else if (args[4] !== void 0) {
      captured_id = args[4];
    } else {
      throw new Error("Unexpected: empty match for citation id.");
    }
    let result = void 0;
    if (args[1] !== void 0 && args[5] === void 0) {
      result = args[1];
    } else if (args[5] !== void 0) {
      result = args[5];
    } else if (args[3] !== void 0 && args[1] === void 0 && args[5] === void 0) {
      result = "std";
    }
    return new Citation(captured_id, result);
  }
  constructor(id, result) {
    this.id = id;
    this.result = result;
  }
  async unroll() {
    return [this];
  }
  async latex(buffer, buffer_offset, settings) {
    if (this.result !== void 0) {
      if (this.result === "std") {
        return buffer_offset + buffer.write("\\cite{" + this.id + "}", buffer_offset);
      } else if (this.result === "txt") {
        return buffer_offset + buffer.write("\\textcite{" + this.id + "}", buffer_offset);
      }
      return buffer_offset + buffer.write(
        "\\cite[" + this.result + "]{" + this.id + "}",
        buffer_offset
      );
    }
    return buffer_offset + buffer.write(
      "\\" + settings.default_citation_command + "{" + this.id + "}",
      buffer_offset
    );
  }
};
var MultiCitation = class {
  static get_regexp() {
    return /(?:\[std\])?\[\[@([^\]:\|]*?)(?:\#[^\]\|]*?)?(?:\|[^\]]*?)?\]\]\[\[@([^\]:\|]*?)(?:\#[^\]\|]*?)?(?:\|[^\]]*?)?\]\](?:\[\[@([^\]:\|]*?)(?:\#[^\]\|]*?)?(?:\|[^\]]*?)?\]\])?(?:\[\[@([^\]:\|]*?)(?:\#[^\]\|]*?)?(?:\|[^\]]*?)?\]\])?(?:\[\[@([^\]:\|]*?)(?:\#[^\]\|]*?)?(?:\|[^\]]*?)?\]\])?(?:\[\[@([^\]:\|]*?)(?:\#[^\]\|]*?)?(?:\|[^\]]*?)?\]\])?(?:\[\[@([^\]:\|]*?)(?:\#[^\]\|]*?)?(?:\|[^\]]*?)?\]\])?(?:\[\[@([^\]:\|]*?)(?:\#[^\]\|]*?)?(?:\|[^\]]*?)?\]\])?(?:\[\[@([^\]:\|]*?)(?:\#[^\]\|]*?)?(?:\|[^\]]*?)?\]\])?(?:\[\[@([^\]:\|]*?)(?:\#[^\]\|]*?)?(?:\|[^\]]*?)?\]\])?(?:\[\[@([^\]:\|]*?)(?:\#[^\]\|]*?)?(?:\|[^\]]*?)?\]\])?(?:\[\[@([^\]:\|]*?)(?:\#[^\]\|]*?)?(?:\|[^\]]*?)?\]\])?(?:\[\[@([^\]:\|]*?)(?:\#[^\]\|]*?)?(?:\|[^\]]*?)?\]\])?(?:\[\[@([^\]:\|]*?)(?:\#[^\]\|]*?)?(?:\|[^\]]*?)?\]\])?(?:\[\[@([^\]:\|]*?)(?:\#[^\]\|]*?)?(?:\|[^\]]*?)?\]\])?(?:\[\[@([^\]:\|]*?)(?:\#[^\]\|]*?)?(?:\|[^\]]*?)?\]\])?(?:\[\[@([^\]:\|]*?)(?:\#[^\]\|]*?)?(?:\|[^\]]*?)?\]\])?(?:\[\[@([^\]:\|]*?)(?:\#[^\]\|]*?)?(?:\|[^\]]*?)?\]\])?/g;
  }
  static build_from_match(args) {
    return new MultiCitation(args);
  }
  constructor(args) {
    this.ids = [];
    for (const id of args.slice(1)) {
      if (id === void 0) {
        break;
      }
      this.ids.push(id);
    }
  }
  async unroll() {
    return [this];
  }
  async latex(buffer, buffer_offset) {
    buffer_offset += buffer.write("\\cite{", buffer_offset);
    for (const id of this.ids.slice(0, -1)) {
      buffer_offset += buffer.write(id + ", ", buffer_offset);
    }
    buffer_offset += buffer.write(
      this.ids[this.ids.length - 1] + "}",
      buffer_offset
    );
    return buffer_offset;
  }
};
var PandocMultiCitation = class {
  static get_regexp() {
    return /(?<!\[)\[?@([a-zA-Z0-9\-_]+);[ \t]*(?:@([a-zA-Z0-9\-_]+))?(?:;[ \t]@([a-zA-Z0-9\-_]+))?(?:;[ \t]@([a-zA-Z0-9\-_]+))?(?:;[ \t]@([a-zA-Z0-9\-_]+))?(?:;[ \t]@([a-zA-Z0-9\-_]+))?(?:;[ \t]@([a-zA-Z0-9\-_]+))?(?:;[ \t]@([a-zA-Z0-9\-_]+))?(?:;[ \t]@([a-zA-Z0-9\-_]+))?(?:;[ \t]@([a-zA-Z0-9\-_]+))?(?:;[ \t]@([a-zA-Z0-9\-_]+))?(?:;[ \t]@([a-zA-Z0-9\-_]+))?(?:;[ \t]@([a-zA-Z0-9\-_]+))?(?:;[ \t]@([a-zA-Z0-9\-_]+))?(?:;[ \t]@([a-zA-Z0-9\-_]+))?(?:;[ \t]@([a-zA-Z0-9\-_]+))?(?:;[ \t]@([a-zA-Z0-9\-_]+))?(?:;[ \t]@([a-zA-Z0-9\-_]+))?(?:;[ \t]@([a-zA-Z0-9\-_]+))?(?:;[ \t]@([a-zA-Z0-9\-_]+))?\]?/g;
  }
  static build_from_match(args) {
    return new PandocMultiCitation(args);
  }
  constructor(args) {
    this.ids = [];
    for (const id of args.slice(1)) {
      if (id === void 0) {
        break;
      }
      this.ids.push(id);
    }
  }
  async unroll() {
    return [this];
  }
  async latex(buffer, buffer_offset) {
    buffer_offset += buffer.write("\\cite{", buffer_offset);
    for (const id of this.ids.slice(0, -1)) {
      buffer_offset += buffer.write(id + ", ", buffer_offset);
    }
    buffer_offset += buffer.write(
      this.ids[this.ids.length - 1] + "}",
      buffer_offset
    );
    return buffer_offset;
  }
};

// src/export_longform/parseMarkdown.ts
var import_obsidian3 = require("obsidian");
async function parse_longform(read_tfile, find_file, longform_file, settings, selection) {
  if (longform_file === void 0) {
    throw new Error(`File not found: ${longform_file}`);
  }
  let file_contents;
  if (selection === void 0) {
    file_contents = await read_tfile(longform_file);
  } else {
    file_contents = selection;
  }
  const parsed_longform = parse_note(file_contents, settings);
  const cache = {};
  cache[longform_file.basename] = parsed_longform;
  let parsed_content = parsed_longform.body;
  let abstract_header;
  for (const e of parsed_content) {
    if (e instanceof Header && (await e.latex_title(settings)).toLowerCase().trim() === "abstract") {
      abstract_header = e;
      parsed_content = parsed_content.filter((x) => x !== e);
    }
  }
  let appendix_header;
  for (const e of parsed_content) {
    if (e instanceof Header && (await e.latex_title(settings)).toLowerCase().trim() === "appendix") {
      appendix_header = e;
      parsed_content = parsed_content.filter((x) => x !== e);
    }
  }
  let body_header_content = parsed_content;
  let body_header = void 0;
  for (const e of parsed_content) {
    if (e instanceof Header && (await e.latex_title(settings)).toLowerCase().trim() === "body") {
      body_header = e;
      lower_headers([body_header]);
      body_header_content = e.children;
    }
  }
  const data = init_data(longform_file, read_tfile, find_file);
  data.parsed_file_bundle = cache;
  if (abstract_header !== void 0) {
    data.header_stack = [abstract_header];
  }
  const abstract_unrolled_content = abstract_header === void 0 ? void 0 : await unroll_array(data, abstract_header.children, settings);
  if (body_header !== void 0) {
    data.header_stack = [body_header];
  }
  const body_unrolled_content = await unroll_array(
    data,
    body_header_content,
    settings
  );
  if (appendix_header !== void 0) {
    data.header_stack = [appendix_header];
  }
  const appendix_unrolled_content = appendix_header === void 0 ? void 0 : await unroll_array(data, appendix_header.children, settings);
  const abstract_string = abstract_unrolled_content === void 0 ? void 0 : await render_content(data, abstract_unrolled_content, settings);
  const body_string = await render_content(
    data,
    body_unrolled_content,
    settings
  );
  const appendix_string = appendix_unrolled_content === void 0 ? void 0 : await render_content(data, appendix_unrolled_content, settings);
  return {
    yaml: parsed_longform.yaml,
    abstract: abstract_string,
    body: body_string,
    appendix: appendix_string,
    media_files: data.media_files,
    bib_keys: data.bib_keys
  };
}
function lower_headers(content) {
  for (const e of content) {
    if (e instanceof Header) {
      e.level -= 1;
      lower_headers(e.children);
    }
  }
}
async function render_content(data, content, settings) {
  const buffer = Buffer.alloc(1e7);
  let offset = 0;
  for (const elt of content) {
    offset = await elt.latex(buffer, offset, settings);
  }
  return buffer.toString("utf8", 0, offset);
}
async function export_selection(read_tfile, find_file, longform_file, selection, settings) {
  const parsed_contents = await parse_longform(
    read_tfile,
    find_file,
    longform_file,
    settings,
    selection
  );
  if (selection !== void 0) {
    const content = join_sections(parsed_contents);
    await navigator.clipboard.writeText(content);
    new import_obsidian3.Notice("Latex content copied to clipboard");
    return;
  }
}
async function write_with_template(template_file, parsed_contents, output_file, modify_tfile, read_tfile) {
  let template_content = await read_tfile(template_file);
  for (const key of Object.keys(parsed_contents["yaml"])) {
    template_content = template_content.replace(
      RegExp(`\\$${key}\\$`, "i"),
      parsed_contents["yaml"][key]
    );
  }
  template_content = template_content.replace(
    /\$body\$/i,
    parsed_contents["body"]
  );
  if (parsed_contents["abstract"] !== void 0) {
    if (template_file) {
      template_content = template_content.replace(
        /\$abstract\$/i,
        parsed_contents["abstract"]
      );
    } else {
      template_content;
    }
  }
  if (parsed_contents["appendix"] !== void 0) {
    template_content = template_content.replace(
      /\$appendix\$/i,
      parsed_contents["appendix"]
    );
  }
  await modify_tfile(output_file, template_content);
}
function join_sections(parsed_contents) {
  let content = "";
  if (parsed_contents["abstract"] !== void 0) {
    content = content + `\\begin{abstract}
` + parsed_contents["abstract"] + `\\end{abstract}
`;
  }
  content += parsed_contents["body"];
  if (parsed_contents["appendix"] !== void 0) {
    content += `\\printbibliography
`;
    content += `\\appendix
\\section{Appendix}
` + parsed_contents["appendix"];
  }
  return content;
}
async function write_without_template(parsed_contents, output_file, modify, preamble_file) {
  let content = `\\documentclass{article}
\\input{header}
`;
  if (preamble_file !== void 0) {
    content += "\\input{" + preamble_file.name + "}\n";
  }
  content += `\\addbibresource{bibliography.bib}
`;
  content += `\\title{`;
  if (parsed_contents["yaml"]["title"] !== void 0) {
    content += parsed_contents["yaml"]["title"];
  }
  content += `}
`;
  if (parsed_contents["yaml"]["author"] !== void 0) {
    content += `\\author{` + parsed_contents["yaml"]["author"] + `}
`;
  }
  content += `\\begin{document}
\\maketitle
`;
  if (parsed_contents["abstract"] !== void 0) {
    content = content + `\\begin{abstract}
` + parsed_contents["abstract"] + `\\end{abstract}
`;
  }
  content += parsed_contents["body"] + `\\printbibliography
`;
  if (parsed_contents["appendix"] !== void 0) {
    content += `\\appendix
\\section{Appendix}
` + parsed_contents["appendix"];
  }
  content += "\\end{document}";
  await modify(output_file, content);
}
function traverse_tree_and_parse_display(md, settings) {
  const new_md = [];
  for (const elt of md) {
    if (elt instanceof Paragraph) {
      const parsed_objects = parse_after_headers([elt], settings);
      new_md.push(...parsed_objects);
    } else if (elt instanceof Header) {
      elt.children = traverse_tree_and_parse_display(
        elt.children,
        settings
      );
      new_md.push(elt);
    } else {
      new_md.push(elt);
    }
  }
  return new_md;
}
function traverse_tree_and_parse_inline(md, settings) {
  for (const elt of md) {
    if (elt instanceof Header) {
      traverse_tree_and_parse_inline(elt.children, settings);
      elt.title = parse_inline(elt.title, settings);
    } else if (elt instanceof NumberedList) {
      for (const e of elt.content) {
        traverse_tree_and_parse_inline(e, settings);
      }
    } else if (elt instanceof UnorderedList) {
      for (const e of elt.content) {
        traverse_tree_and_parse_inline(e, settings);
      }
    } else if (elt instanceof Paragraph) {
      elt.elements = parse_inline(elt.elements, settings);
    }
  }
}
function parse_note(file_contents, settings) {
  const [yaml, body] = parse_display(file_contents, settings);
  let parsed_contents = make_heading_tree(body);
  parsed_contents = traverse_tree_and_parse_display(
    parsed_contents,
    settings
  );
  traverse_tree_and_parse_inline(parsed_contents, settings);
  return { yaml, body: parsed_contents };
}
async function parse_embed_content(address, find_file, read_tfile, parsed_cache, settings, header) {
  const file_found = find_file(address);
  if (file_found === void 0) {
    return void 0;
  }
  if (!(file_found.basename in Object.keys(parsed_cache))) {
    const file_contents = await read_tfile(file_found);
    parsed_cache[file_found.basename] = parse_note(file_contents, settings);
  }
  const content = parsed_cache[file_found.basename];
  if (content === void 0) {
    return void 0;
  }
  if (header === void 0) {
    return [content.body, 0];
  }
  const header_elt = await find_header(header, [content.body], settings);
  if (header_elt === void 0) {
    notice_and_warn(
      "Header not found: " + header + " in file with address " + address
    );
    return void 0;
  }
  return [header_elt.children, header_elt.level];
}
function parse_display(input, settings) {
  const parsed_yaml = parse_yaml_header(input);
  let new_display = [new Paragraph([new Text(parsed_yaml[1])])];
  new_display = split_display(
    new_display,
    Comment.build_from_match,
    Comment.get_regexp(),
    settings
  );
  new_display = split_display(
    new_display,
    Quote.build_from_match,
    Quote.get_regexp(),
    settings
  );
  new_display = split_display(
    new_display,
    EmbedWikilink.build_from_match,
    EmbedWikilink.get_regexp(),
    settings
  );
  return [parsed_yaml[0], new_display];
}
var ZeroHeader = class {
  constructor(content) {
    this.level = 0;
    this.children = content;
  }
};
function make_heading_tree(markdown) {
  let headingRegex = /^(#+) (.*)$/gm;
  const new_md = new ZeroHeader([]);
  let header_stack = [];
  header_stack.push(new_md);
  let new_display = new_md.children;
  let current_match;
  for (const elt of markdown) {
    if (elt instanceof Paragraph) {
      console.assert(
        elt.elements.length == 1,
        "Paragraph should have only one element at this stage of parsing"
      );
      console.assert(
        elt.elements[0] instanceof Text,
        "Paragraph should have only one text element at this stage of parsing"
      );
      const inline_element = elt.elements[0];
      let start_index = 0;
      while ((current_match = headingRegex.exec(inline_element.content)) !== null) {
        if (current_match.index == void 0) {
          throw new Error("current_match.index is undefined");
        }
        const prev_chunk = inline_element.content.slice(
          start_index,
          current_match.index
        );
        if (prev_chunk.trim() !== "") {
          new_display.push(
            new Paragraph([new Text(strip_newlines(prev_chunk))])
          );
        }
        for (let i = header_stack.length - 1; i >= 0; i--) {
          const new_header = new Header(
            current_match[1].length,
            [new Text(current_match[2])],
            []
          );
          const level = new_header.level;
          if (level > header_stack[i].level) {
            header_stack.splice(
              i + 1,
              header_stack.length - (i + 1)
            );
            header_stack[i].children.push(new_header);
            header_stack.push(new_header);
            new_display = new_header.children;
            break;
          }
        }
        start_index = current_match.index + current_match[0].length;
      }
      const return_string = inline_element.content.slice(start_index);
      if (return_string.trim() !== "") {
        new_display.push(
          new Paragraph([new Text(strip_newlines(return_string))])
        );
      }
    } else {
      new_display.push(elt);
    }
  }
  return new_md.children;
}
function parse_after_headers(new_display, settings) {
  new_display = split_display(
    new_display,
    Environment.build_from_match,
    Environment.get_regexp(),
    settings
  );
  new_display = split_display(
    new_display,
    BlankLine.build_from_match,
    BlankLine.get_regexp(),
    settings
  );
  if (!settings.prioritize_lists) {
    new_display = split_display(
      new_display,
      DisplayMath.build_from_match,
      DisplayMath.get_regexp(),
      settings
    );
  }
  new_display = split_display(
    // Lists parse until the end of the string. What limits them is the presence of other elements in front of them.
    new_display,
    NumberedList.build_from_match,
    NumberedList.get_regexp(),
    settings
  );
  for (const elt of new_display) {
    if (elt instanceof NumberedList) {
      const new_content = [];
      for (const e of elt.content) {
        new_content.push(parse_after_headers(e, settings));
      }
      elt.content = new_content;
    }
  }
  new_display = split_display(
    new_display,
    UnorderedList.build_from_match,
    UnorderedList.get_regexp(),
    settings
  );
  for (const elt of new_display) {
    if (elt instanceof UnorderedList) {
      const new_content = [];
      for (const e of elt.content) {
        new_content.push(parse_after_headers(e, settings));
      }
      elt.content = new_content;
    }
  }
  if (settings.prioritize_lists) {
    new_display = split_display(
      new_display,
      DisplayMath.build_from_match,
      DisplayMath.get_regexp(),
      settings
    );
  }
  return new_display;
}
function parse_yaml_header(input) {
  const match = /^---\n(.*?)---\n(.*)$/s.exec(input);
  if (!match) {
    return [{}, input];
  }
  return [(0, import_obsidian3.parseYaml)(match[1]), match[2]];
}
function parse_inline(inline_arr, settings) {
  inline_arr = split_inline(
    inline_arr,
    ExplicitRef.get_regexp(),
    ExplicitRef.build_from_match,
    settings
  );
  inline_arr = split_inline(
    inline_arr,
    MultiCitation.get_regexp(),
    MultiCitation.build_from_match,
    settings
  );
  inline_arr = split_inline(
    inline_arr,
    PandocMultiCitation.get_regexp(),
    PandocMultiCitation.build_from_match,
    settings
  );
  inline_arr = split_inline(
    inline_arr,
    Citation.get_regexp(),
    Citation.build_from_match,
    settings
  );
  inline_arr = split_inline(
    inline_arr,
    Wikilink.get_regexp(),
    Wikilink.build_from_match,
    settings
  );
  inline_arr = split_inline(
    inline_arr,
    InlineMath.get_regexp(),
    InlineMath.build_from_match,
    settings
  );
  inline_arr = split_inline(
    inline_arr,
    DoubleQuotes.get_regexp(),
    DoubleQuotes.build_from_match,
    settings
  );
  inline_arr = split_inline(
    inline_arr,
    SingleQuotes.get_regexp(),
    SingleQuotes.build_from_match,
    settings
  );
  inline_arr = split_inline(
    inline_arr,
    Strong.get_regexp(),
    Strong.build_from_match,
    settings
  );
  inline_arr = split_inline(
    inline_arr,
    Emphasis.get_regexp(),
    Emphasis.build_from_match,
    settings
  );
  return inline_arr;
}

// src/export_longform/get_header_tex.ts
function get_header_tex() {
  return `\\usepackage{amsmath}
\\usepackage{amsthm}
\\usepackage{aliascnt}
\\usepackage{biblatex}
\\usepackage{graphicx}
\\usepackage{hyperref}

\\usepackage{listings}
\\usepackage{color}

\\definecolor{dkgreen}{rgb}{0,0.6,0}
\\definecolor{gray}{rgb}{0.5,0.5,0.5}
\\definecolor{mauve}{rgb}{0.58,0,0.82}

\\lstset{frame=tb,
  language=python,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\\small\\ttfamily},
  numbers=none,
  numberstyle=\\tiny\\color{gray},
  keywordstyle=\\color{blue},
  commentstyle=\\color{dkgreen},
  stringstyle=\\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\\theoremstyle{plain}
\\newtheorem{theorem}{Theorem}[section]

\\renewcommand{\\equationautorefname}{Equation}

\\renewcommand{\\sectionautorefname}{Section} % name for \\autoref
\\renewcommand{\\subsectionautorefname}{Section} % name for \\autoref
\\renewcommand{\\subsubsectionautorefname}{Section} % name for \\autoref

\\newaliascnt{proposition}{theorem}% alias counter "<newTh>"
\\newtheorem{proposition}[proposition]{Proposition}
\\aliascntresetthe{proposition}
\\providecommand*{\\propositionautorefname}{Proposition} % name for \\autoref

\\newaliascnt{corollary}{theorem}% alias counter "<newTh>"
\\newtheorem{corollary}[corollary]{Corollary}
\\aliascntresetthe{corollary}
\\providecommand*{\\corollaryautorefname}{Corollary} % name for \\autoref

\\newaliascnt{lemma}{theorem}% alias counter "<newTh>"
\\newtheorem{lemma}[lemma]{Lemma}
\\aliascntresetthe{lemma}
\\providecommand*{\\lemmaautorefname}{Lemma} % name for \\autoref

\\theoremstyle{definition}
\\newtheorem{definition}{Definition}[section]
\\newtheorem{example}{Example}

\\theoremstyle{remark}
\\newtheorem{rmk}{Remark}[section]
\\newtheorem{fact}[rmk]{Fact}
\\newtheorem*{rmk*}{Remark}
\\newtheorem*{fact*}{Fact}

\\newenvironment{remark}
{\\pushQED{\\qed}\\renewcommand{\\qedsymbol}{$\\diamond$}\\rmk}
{\\popQED\\endrmk}

\\providecommand*{\\remarkautorefname}{Remark} % name for \\autoref
\\providecommand*{\\rmkautorefname}{Remark} % name for \\autoref
\\providecommand*{\\definitionautorefname}{Definition} % name for \\autoref`;
}

// src/main.ts
var ExportPaperPlugin = class extends import_obsidian4.Plugin {
  constructor() {
    super(...arguments);
    this.find_file = (address) => {
      const temp_result = this.app.metadataCache.getFirstLinkpathDest(
        address,
        "/"
      );
      if (temp_result) {
        return temp_result;
      } else {
        return void 0;
      }
    };
  }
  async find_files_and_export(active_file, settings) {
    if (this.settings.base_output_folder === "") {
      this.settings.base_output_folder = "/";
    }
    let base_folder = this.app.vault.getFolderByPath(
      this.settings.base_output_folder
    );
    if (!base_folder) {
      base_folder = this.app.vault.getRoot();
      console.warn(
        "Output folder path not found, defaulting to the root of the vault."
      );
      new import_obsidian4.Notice(
        "Output folder path not found, defaulting to the root of the vault."
      );
    }
    const output_file_name = active_file.basename + "_output.tex";
    let output_folder_path = path2.join(
      base_folder.path,
      active_file.basename.replace(/ /g, "_")
    );
    const output_folder_match = /^\/(.*)$/.exec(output_folder_path);
    if (output_folder_match) {
      output_folder_path = output_folder_match[1];
    }
    let output_path = path2.join(output_folder_path, output_file_name);
    await this.app.vault.createFolder(output_folder_path).catch((e) => e);
    const the_preamble_file = this.app.vault.getFileByPath(
      this.settings.preamble_file
    );
    let export_message = "Exporting the current file:\n";
    const preamble_file = the_preamble_file ? the_preamble_file : void 0;
    if (preamble_file !== void 0) {
      const new_preamble = path2.join(output_folder_path, "preamble.sty");
      if (!this.app.vault.getFileByPath(new_preamble)) {
        this.app.vault.copy(preamble_file, new_preamble);
        export_message += "- Copying the preamble file\n";
      } else {
        export_message += "- Without overwriting the preamble file\n";
      }
    } else {
      export_message += " - Without a preamble file (none found)\n";
    }
    const header_file = this.app.vault.getFileByPath(
      path2.join(output_folder_path, "header.tex")
    );
    if (!header_file) {
      export_message += "- Creating the header file\n";
      await this.app.vault.create(
        path2.join(output_folder_path, "header.tex"),
        get_header_tex()
      );
    } else {
      export_message += "- Without overwriting the header file\n";
    }
    const the_bib_file = this.app.vault.getFileByPath(
      this.settings.bib_file
    );
    const bib_file = the_bib_file ? the_bib_file : void 0;
    if (bib_file !== void 0) {
      const new_bib = path2.join(output_folder_path, "bibliography.bib");
      if (!this.app.vault.getFileByPath(new_bib)) {
        export_message += "- Copying the bib file\n";
        this.app.vault.copy(bib_file, new_bib);
      } else {
        export_message += "- Without overwriting the bib file\n";
      }
    } else {
      export_message += "- Without a bib file (none found)";
    }
    const the_template_file = this.app.vault.getFileByPath(
      this.settings.template_path
    );
    const template_file = the_template_file !== null ? the_template_file : void 0;
    if (template_file !== void 0) {
      export_message += "- Using the specified template file,\n";
    }
    let out_file = this.app.vault.getFileByPath(output_path);
    if (out_file === null) {
      out_file = await this.app.vault.create(output_path, "");
      await this.proceed_with_export(
        active_file,
        settings,
        output_folder_path,
        template_file,
        out_file,
        preamble_file,
        export_message
      );
    } else {
      const out_file_other = out_file;
      if (this.settings.warn_before_overwrite) {
        new WarningModal(
          this.app,
          this,
          () => this.proceed_with_export(
            active_file,
            settings,
            output_folder_path,
            template_file,
            out_file_other,
            preamble_file,
            export_message
          ),
          "It seems there is a previously exported file. Overwrite it?"
        ).open();
      } else {
        await this.proceed_with_export(
          active_file,
          settings,
          output_folder_path,
          template_file,
          out_file,
          preamble_file,
          export_message
        );
      }
    }
  }
  async proceed_with_export(active_file, settings, output_folder_path, template_file, out_file, preamble_file, partial_message = "") {
    const notes_dir = this.app.vault;
    const parsed_contents = await parse_longform(
      notes_dir.cachedRead.bind(notes_dir),
      this.find_file,
      active_file,
      settings
    );
    if (parsed_contents.media_files.length > 0) {
      const files_folder = path2.join(output_folder_path, "Files");
      await this.app.vault.createFolder(files_folder).catch((e) => e);
      for (const media_file of parsed_contents.media_files) {
        await this.app.vault.copy(media_file, path2.join(files_folder, media_file.name)).catch((e) => e);
      }
    }
    if (template_file !== void 0) {
      await write_with_template(
        template_file,
        parsed_contents,
        out_file,
        notes_dir.modify.bind(notes_dir),
        notes_dir.cachedRead.bind(notes_dir)
      );
    } else {
      await write_without_template(
        parsed_contents,
        out_file,
        notes_dir.modify.bind(notes_dir),
        preamble_file
      );
    }
    new import_obsidian4.Notice(
      partial_message + "To the vault folder inside the vault:\n" + output_folder_path + "/"
    );
  }
  async export_with_selection(active_file, selection, settings) {
    try {
      return export_selection(
        this.app.vault.cachedRead.bind(this.app.vault),
        this.find_file,
        active_file,
        selection,
        settings
      );
    } catch (e) {
      console.error(e);
    }
  }
  async onload() {
    await this.loadSettings();
    this.addCommand({
      id: "export-paper",
      name: "Export current note",
      checkCallback: (checking) => {
        const active_file = this.app.workspace.getActiveFile();
        if (!(active_file instanceof import_obsidian4.TFile)) {
          return false;
        } else if (checking) {
          return true;
        } else {
          this.find_files_and_export(active_file, this.settings);
        }
      }
    });
    this.addCommand({
      id: "selection-export-paper",
      name: "Export selection",
      editorCheckCallback: (checking, editor, ctx) => {
        if (checking) {
          return editor.somethingSelected();
        }
        const active_file = ctx.file;
        if (!active_file) {
          throw new Error("No active file found.");
        }
        const selection = editor.getSelection();
        this.export_with_selection(
          active_file,
          selection,
          this.settings
        );
      }
    });
    this.addSettingTab(new LatexExportSettingTab(this.app, this));
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var WarningModal = class extends import_obsidian4.Modal {
  constructor(app, plugin, callback, message) {
    super(app);
    this.plugin = plugin;
    this.rememberChoice = false;
    this.callback = callback;
    this.message = message;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.setText(this.message);
    new import_obsidian4.Setting(contentEl).addButton(
      (btn) => btn.setButtonText("OK").onClick(async () => {
        if (this.rememberChoice) {
          this.plugin.settings.warn_before_overwrite = false;
        }
        await this.callback();
        await this.plugin.saveSettings();
        this.close();
      })
    ).addButton(
      (btn) => btn.setButtonText("Cancel").onClick(() => {
        this.close();
      })
    );
    const toggleContainer = contentEl.createDiv();
    toggleContainer.createDiv({ text: "Remember my choice:" });
    new import_obsidian4.Setting(toggleContainer).addToggle(
      (toggle) => toggle.setValue(false).onChange((value) => this.rememberChoice = value)
    );
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var LatexExportSettingTab = class extends import_obsidian4.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian4.Setting(containerEl).setName("Template file").setDesc(
      "Relative vault path to a template file. Only set this if you would like to export with a template (you don't need to.)"
    ).addText(
      (text) => text.setPlaceholder("path/to/template_file.tex").setValue(this.plugin.settings.template_path).onChange(async (value) => {
        if (value === "") {
          value = "/";
        }
        this.plugin.settings.template_path = (0, import_obsidian4.normalizePath)(value);
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Output folder").setDesc(
      "Vault relative path of an existing folder in your vault. Exports will be written within that folder."
    ).addText(
      (text) => text.setPlaceholder("path/to/output_folder/").setValue(this.plugin.settings.base_output_folder).onChange(async (value) => {
        const match = /^(?:\/|\/?(.*?)\/?)$/.exec(value);
        if (match) {
          if (match[1] === void 0) {
            value = "/";
          } else {
            value = match[1];
          }
        }
        this.plugin.settings.base_output_folder = (0, import_obsidian4.normalizePath)(value);
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Math preamble file").setDesc(
      "Vault relative path to a preamble.sty file in your vault. It will be included in the export."
    ).addText(
      (text) => text.setPlaceholder("path/to/preamble_file").setValue(this.plugin.settings.preamble_file).onChange(async (value) => {
        this.plugin.settings.preamble_file = (0, import_obsidian4.normalizePath)(value);
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Bib file").addText(
      (text) => text.setPlaceholder("path/to/bib_file").setValue(this.plugin.settings.bib_file).onChange(async (value) => {
        this.plugin.settings.bib_file = (0, import_obsidian4.normalizePath)(value);
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Prioritize lists over equations").setDesc(
      "Whether to include display equations in lists, or stop the list and have the equation outside of the list."
    ).addToggle(
      (cb) => cb.setValue(this.plugin.settings.prioritize_lists).onChange(async (value) => {
        this.plugin.settings.prioritize_lists = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Warn before overwriting on export").addToggle(
      (cb) => cb.setValue(this.plugin.settings.warn_before_overwrite).onChange(async (value) => {
        this.plugin.settings.warn_before_overwrite = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Default cite command").addText(
      (txt) => txt.setValue(this.plugin.settings.default_citation_command).onChange(async (value) => {
        this.plugin.settings.default_citation_command = value;
        await this.plugin.saveSettings();
      })
    );
  }
};

/* nosourcemap */